"""
Builds a full-genome prg starting from:
    * A dataset name. This is used to map to i)a reference genome ii)a set of vcfs containing the variation that will go in the prg
    * A gene list name. This is used to map to a bed file of regions for which the variation is added to the prg.

These two values need to be changed in 'make_prgs.yaml' config to trigger a different prg build; also, see the relevant functions in 'utils.py' to define ref genome and vcf to use.
"""
from pathlib import Path

WORKFLOW = "make_prgs"


configfile: "analysis/configs/common.yaml"
configfile: f"analysis/configs/{WORKFLOW}.yaml"


container: config["container_gramtools"]


include: f"../common_utils.py"
GMTOOLS_COMMIT = get_gmtools_commit(config["container_gramtools"])
include: f"../{WORKFLOW}/utils.py"

output_base = Path(f'{config["output_dir"]}/{WORKFLOW}')
output_beds = output_base / "beds"


##### 
## Change the parameters below to trigger prg construction for different samples and genes
## This cannot cheaply be automated, because of rule 'mp_induce_gene_sequences' needs to know the set of genes produced; the alternative is to run this rule sample x gene times, but that's too many jobs.

## P falciparum
# pf6 analysis 3k subset
#dataset_name="pf6_analysis_set_3000"
output_gene_portions = output_base / "gene_portions_pf6"
# pf6 analysis set
dataset_name="pf6_analysis_set"
gene_list_name="pf6_26_genes"

## P vivax
#dataset_name="pvgv"
#gene_list_name="pvivax_7_genes"

## "ref" must be prepended to sample names so that we place a ref genome slice at the beginning of the msas/prgs.
sample_names = ["ref"] + get_sample_names(dataset_name)
genes = load_bed(gene_list_name)
##### 

output_catted_genes = Path(
    f'{output_base}/{dataset_name}/catted_genes'
    )
mk_output_dirs(dir())


rule all:
    input:
        prgs=expand(
            f"{output_base}/{dataset_name}/mn5_mml{{min_match_len}}/{gene_list_name}_prg",
            min_match_len=config["min_match_len"],
        ),


rule mp_make_beds:
    input:
        bed=f'{config["gene_bed_dir"]}/{gene_list_name}.bed',
        ref_genome_index=f'{get_ref_genome_no_wildcards(dataset_name)}.fai',
    output:
        bed_genes=f'{output_beds}/{gene_list_name}/genes_{config["flank_size"]}.bed',
        bed_invariants=(
            f"{output_beds}/{gene_list_name}/invariant.bed"
        ),
        bed_full=f'{output_beds}/{gene_list_name}/genes_{config["flank_size"]}_and_invariant.bed',
    params:
        extension_script=f'{config["scripts"]}/{WORKFLOW}/extend_intervals.py',
        flank_size=config["flank_size"],
    shadow:
        "shallow"
    shell:
        # Assumes input.bed is sorted
        """
        mkdir -p $(dirname {output.bed_genes})
        python3 {params.extension_script} {input.bed} {params.flank_size} {output.bed_genes} --force
        bedtools complement -i {output.bed_genes} -g {input.ref_genome_index} | awk 'BEGIN{{l=1}}{{print $0"\t""nonvar_"l;l+=1}}' > {output.bed_invariants}

        cat {output.bed_genes} {output.bed_invariants} > tmp.bed
        bedtools sort -i tmp.bed -faidx {input.ref_genome_index} > {output.bed_full}
        """


rule mp_induce_gene_sequences:
    input:
        bed_genes=rules.mp_make_beds.output.bed_genes,
        ref_genome=get_ref_genome_no_wildcards(dataset_name),
        vcf=get_one_vcf,
    output:
        expand(
            f"{output_gene_portions}/{{sample_name}}/{{gene}}.fa",
            gene=genes,
            allow_missing=True,
        ),
    shadow:
        "shallow"
    shell:
        """
        outdir=$(dirname {output[0]})
        mkdir -p "$outdir"
        cp {input.vcf} input.vcf.gz
        bcftools index input.vcf.gz
        IFS="\n"; for gene_line in $(cat {input.bed_genes})
        do
            IFS="\t"; elems=($gene_line)    
            adj_start=$((${{elems[1]}} + 1))
            reg="${{elems[0]}}:${{adj_start}}-${{elems[2]}}"
            gene_name=${{elems[3]}}
            fout=${{outdir}}/${{gene_name}}.fa
            samtools faidx {input.ref_genome} $reg | bcftools consensus input.vcf.gz |
                sed 's/>.*/>'{wildcards.sample_name}'/' > $fout
        done
        """


rule mp_cat_var_portions:
    input:
        samples=expand(
            f"{output_gene_portions}/{{sample_name}}/{{gene}}.fa",
            sample_name=sample_names,
            allow_missing=True,
        ),
    output:
        gene_seqs=f"{output_base}/{{dataset_name}}/catted_genes/{{gene}}.fa",
    run:
        # Use run, not shell, as too long list of arguments to shell script failed in snakemake v5.14.0.
        with open(output.gene_seqs, "w") as fout:
            for portion in input.samples:
                with open(portion) as fin:
                    sequence = fin.read()
                fout.write(sequence)


rule mp_make_msas:
    input:
        rules.mp_cat_var_portions.output.gene_seqs,
    output:
        gene_msa=(
            f"{output_base}/{{dataset_name}}/msas/{{gene}}.msa"
        ),
    resources:
        mem_mb=8000,
    shell:
        """
        mkdir -p $(dirname {output.gene_msa})
        mafft {input} > {output.gene_msa}
        """


rule mp_make_var_prg:
    input:
        rules.mp_make_msas.output.gene_msa,
    output:
        gene_prg=f"{output_base}/{{dataset_name}}/mn5_mml{{min_match_len}}/{{gene}}.bin",
    resources:
        mem_mb=5000,
    shadow:
        "shallow"
    shell:
        """
        mkdir -p $(dirname {output})
        make_prg from_msa --max_nesting 5 --min_match_length {wildcards.min_match_len} -n {wildcards.gene} {input}
        mv {wildcards.gene}.bin {output}
        """


rule mp_make_nonvar_prg_portions:
    input:
        nonvars=rules.mp_make_beds.output.bed_invariants,
        ref_genome=get_ref_genome,
    output:
        nonvar_prgs=touch(
            f"{output_base}/{{dataset_name}}/mn5_mml{{min_match_len}}/nonvars_done.txt"
        ),
    shell:
        """
        outdir=$(dirname {output[0]})
        IFS="\n"; for nonvar_line in $(cat {input.nonvars})
        do
            IFS="\t"; elems=($nonvar_line)    
            adj_start=$((${{elems[1]}} + 1))
            reg="${{elems[0]}}:${{adj_start}}-${{elems[2]}}"
            samtools faidx {input.ref_genome} $reg |
                encode_prg -o ${{outdir}}/${{elems[3]}}.bin
        done
        """


rule mp_concat_prgs:
    input:
        nonvar_prgs=rules.mp_make_nonvar_prg_portions.output[0],
        var_prgs=expand(
            f"{output_base}/{{dataset_name}}/mn5_mml{{min_match_len}}/{{gene}}.bin",
            gene=genes,
            allow_missing=True,
        ),
        bed_full=rules.mp_make_beds.output.bed_full,
    output:
        f"{output_base}/{{dataset_name}}/mn5_mml{{min_match_len}}/{{gene_list_name}}_prg",
    params:
        script=f'{config["scripts"]}/{WORKFLOW}/concat_prgs.py',
        prg_dirname=f"{output_base}/{{dataset_name}}/mn5_mml{{min_match_len}}",
    resources:
        mem_mb=15000,
    shell:
        "python3 {params.script} {params.prg_dirname} {input.bed_full} {output}"
