"""
Aggregates sequences from paralogs of interest
"""
from pathlib import Path
from itertools import chain, repeat
import re

WORKFLOW = "plasmo_paralogs"

configfile: "analysis/configs/common.yaml"
configfile: f"analysis/configs/{WORKFLOW}.yaml"

container: config["container_gramtools"]

include: f"../common_utils.py"
GMTOOLS_COMMIT = cu_get_gmtools_commit(config["container_gramtools"])
include: f"../{WORKFLOW}/utils.py"

output_base = Path(f'{config["output_dir"]}/{WORKFLOW}')
output_gene_portions = output_base / "gene_portions"
gram_version = f"gram_jointgeno_{GMTOOLS_COMMIT}"
output_gram_version = output_base / gram_version
cu_mk_output_dirs(dir())

tools=["gapfiller",f"gram_adju_{GMTOOLS_COMMIT}"]
sample_set_names=["pf6_analysis_set_fws95"]

gene_list_name="pf6_26_genes"
genes = pp_filter_to_paralogs(cu_load_bed(gene_list_name))

def pp_get_sample_seqs(wildcards):
    sample_names = ["ref"] + cu_get_sample_names_fws_matching(wildcards.sample_set_name)
    result= expand(
        f"{output_gene_portions}/{gram_version}/{wildcards.sample_set_name}/{wildcards.tool}/{{sample_name}}/{wildcards.paralog}.fa",
        sample_name=sample_names,
    )
    return result

def pp_get_paralog_family(wildcards):
    if wildcards.paralog_abbrev not in config["paralog_abbrevs"]:
        raise ValueError(f"{wildcards.paralog_abbrev} not supported")
    paralog_names = config["paralog_names"][wildcards.paralog_abbrev]
    result=expand(f"{output_base}/{gram_version}/{wildcards.sample_set_name}/{wildcards.tool}/{wildcards.paralog_abbrev}/dna/{{paralog}}.fa", paralog=paralog_names)
    return result

rule all:
    input:
        paralog_seqs=pp_get_all_paralog_regions(expand(
                f"{output_gram_version}/{{sample_set_name}}/{{tool}}/{{paralog_abbrev}}/dna/{{paralog_abbrev}}.fa",
                tool=tools,
                sample_set_name=sample_set_names,
                allow_missing=True
                ))

rule pp_induce_gene_seqs:
    input:
        bed=f'{config["gene_bed_dir"]}/{gene_list_name}.bed',
        vcf=pp_get_one_vcf,
        ref_genome=cu_get_ref_genome_no_wildcards(gene_list_name),
    output:
        expand(
            f"{output_gene_portions}/{gram_version}/{{sample_set_name}}/{{tool}}/{{sample_name}}/{{paralog}}.fa",
            paralog=genes,
            allow_missing=True,
        ),
    params:
        induce_seq_script=f'{config["common_scripts"]}/induce_gene_seqs.sh',
    shadow:
        "shallow"
    shell:
        """
        outdir=$(dirname {output[0]})
        all_samples=0
        if [[ {wildcards.sample_name} == "ref" ]];then all_samples=1;fi
        bash {params.induce_seq_script} {input.bed} {input.vcf} {input.ref_genome} $outdir {wildcards.sample_name} 1 $all_samples
        """

rule pp_cat_gene_seqs:
    input:
        sample_sequences=pp_get_sample_seqs,
    output:
        catted_gene=f"{output_gram_version}/{{sample_set_name}}/{{tool}}/{{paralog_abbrev}}/dna/{{paralog}}.fa",
    wildcard_constraints:
        paralog="[^_]+",
    run:
        # Use run, not shell, as too long list of arguments to shell script failed in snakemake v5.14.0.
        from pathlib import Path
        Path(output.catted_gene).parent.mkdir(exist_ok=True, parents=True)
        with open(output.catted_gene, "w") as fout:
            for portion in input.sample_sequences:
                with open(portion) as fin:
                    sequence = fin.read()
                fout.write(sequence)


rule pp_cat_paralogs:
    input:
        pp_get_paralog_family,
    output:
        dna_seqs=f"{output_gram_version}/{{sample_set_name}}/{{tool}}/{{paralog_abbrev}}/dna/{{paralog_abbrev}}.fa",
    shell:
        """
        cat {input} > {output.dna_seqs}
        """

